# rill

> Scripting language designed for machine-generated code. LLMs generate rill scripts; humans review and debug. Data flows through pipes (`->`), not assignment. Variables use `$` prefix. No null, no exceptions, no truthiness.

## Documentation

- [Getting Started](https://rill.run/docs/guide/getting-started/): Beginner-friendly introduction to rill
- [Language Reference](https://rill.run/docs/reference/language/): Core language specification
- [Examples](https://rill.run/docs/guide/examples/): Workflow patterns and use cases
- [Cookbook](https://rill.run/docs/guide/cookbook/): Advanced agent scripting patterns
- [Types](https://rill.run/docs/language/types/): Primitives, tuples, dicts, type assertions
- [Variables](https://rill.run/docs/language/variables/): Declaration, scope rules, `$` binding
- [Control Flow](https://rill.run/docs/language/control-flow/): Conditionals, loops, break/return
- [Operators](https://rill.run/docs/language/operators/): Arithmetic, comparison, spread, extraction
- [Closures](https://rill.run/docs/language/closures/): Late binding, dict-bound closures
- [Collections](https://rill.run/docs/data/collections/): `each`, `map`, `filter`, `fold` operators
- [Iterators](https://rill.run/docs/data/iterators/): Lazy sequences with `range`, `repeat`, `.first()`
- [Strings](https://rill.run/docs/data/strings/): String methods for text manipulation
- [Host Integration](https://rill.run/docs/integration/host/): Embedding rill in applications
- [Host API Reference](https://rill.run/docs/reference/host-api/): Complete TypeScript API exports
- [Developing Extensions](https://rill.run/docs/integration/extensions/): Writing reusable host function packages
- [Modules](https://rill.run/docs/integration/modules/): Convention for host-provided module systems
- [CLI Tools](https://rill.run/docs/integration/cli/): `rill-exec`, `rill-eval`, `rill-check` commands
- [Error Reference](https://rill.run/docs/reference/errors/): Error codes and resolution

## Essentials

1. Variables use `$` prefix ALWAYS: `5 => $x` (no assignment operator `=`)
2. Pipe with `->`, capture with `=>`: `"hello" => $x -> .upper => $y`
3. No null/undefined, no try/catch, no truthiness (conditions must be boolean)
4. Variables lock to first type: `"hi" => $x; 42 => $x` is an ERROR
5. Loops cannot modify outer vars: use `fold`, `each(init)`, or `$` as state dict

## Strengths and Use Cases

Strengths:
- Unambiguous syntax: `$` prefix, explicit operators, no implicit coercion
- Single-pass parseable: LLMs generate correct code without symbol tables
- Readable by humans: pipe chains show data flow left-to-right
- Safe defaults: immutable values, type locking, no null/undefined

Use cases:
- Workflow orchestration: chain LLM calls, API requests, transformations
- State machines: `(cond) @ { }` loops with `$` as state dict
- Data pipelines: `each`/`map`/`filter`/`fold` process collections declaratively

State machine pattern (`$` carries state through iterations):

    [state: "init", data: $input]
      -> ($.state != "done") @ {
        $.state -> [
          init: { [state: "process", data: transform($.data)] },
          process: { [state: "done", data: finalize($.data)] }
        ]
      }

## Naming Convention: snake_case

Use snake_case for all identifiers:

    $user_name, $item_list, $is_valid    # variables
    $double_value, $cleanup_text         # closures
    [first_name: "x", last_name: "y"]    # dict keys

## Why Variables Use $ Prefix

The `$` prefix enables single-pass parsing without a symbol table:

    name()    -> host function call
    $name()   -> closure invocation
    $name     -> variable reference
    name      -> dict key literal

Without `$`, `process(data)` is ambiguous: is `process` a host function or stored closure? Is `data` a variable or key? This would require tracking all declarations.

## Spacing Rules

    Operators:     space both sides       5 + 3, $x -> .upper, "a" => $b
    Parentheses:   no inner space         ($x + 1), ($ > 3) ? "yes"
    Braces:        space inside           { $x + 1 }, each { $ * 2 }
    Brackets:      no inner space         $list[0], $dict.items[1]
    Literals:      space after , and :    [1, 2, 3], [name: "x", age: 30]
    Closures:      space after params     |x| ($x * 2), |a, b| { $a + $b }
    Methods:       no space before . or ( $str.upper(), $list.join(", ")
    Pipes:         space both sides       "x" -> .upper -> .len
    Continuations: indent 2 spaces        $data
                                            -> .filter { $.active }
                                            -> map { $.name }

## Implicit $ Shorthand (Always Prefer)

    $.method()  ->  .method            "x" -> .upper  (not $.upper())
    func($)     ->  func               "x" -> log     (not log($))
    $fn($)      ->  $fn                5 -> $double   (not $double($))

Don't capture just to continue — use line continuation instead:

    # avoid                          # good
    "x" => $a                        "x"
    $a -> .upper => $b                 -> .upper
    $b -> .len                         -> .len

Only capture when the variable is reused later in the code.

## Critical Differences from Mainstream Languages

### 1. No Assignment Operator

    Wrong: x = 5           Mainstream: x = value
    Right: 5 => $x         rill: value => $x

Pipe (`->`): passes value to next operation.
Capture (`=>`): stores value AND continues chain.
Example: `"hello" => $x -> .upper => $y` — `$x="hello"`, `$y="HELLO"`.

### 2. No Null/Undefined

Empty values (`""`, `[]`, `[:]`) exist. "No value" cannot be represented.
Use `??` for defaults: `$dict.field ?? "default"`.
Use `.empty` to check: `$str -> .empty ? "was empty"`.

### 3. No Truthiness

Conditions MUST be boolean. No implicit coercion.

    Wrong: "" ? "yes" ! "no"       Right: "" -> .empty ? "yes" ! "no"
    Wrong: 0 ? "yes" ! "no"        Right: (0 == 0) ? "yes" ! "no"

Negation (`!`) also requires boolean:

    !true                          # false
    "hello" -> .empty -> (!$)      # true (negates boolean from .empty)
    !"hello"                       # ERROR: Negation requires boolean

### 4. Variables Lock to First Type

    "hello" => $x
    42 => $x        # ERROR: cannot assign number to string variable

### 5. No Variable Shadowing (Critical for Loops)

Child scopes can READ parent variables but cannot WRITE or redeclare them.
Variables created inside blocks/loops do NOT leak out.

WRONG — outer variable modification (NEVER works):

    0 => $count
    [1, 2, 3] -> each { $count + 1 => $count }  # creates LOCAL $count
    $count                                       # still 0!

RIGHT — use `fold` for reduction:

    [1, 2, 3] -> fold(0) { $@ + $ }             # 6 ($@ is accumulator)

RIGHT — use `each(init)` for results AND accumulator:

    [1, 2, 3] -> each(0) { $@ + $ }             # [1, 3, 6] (running totals)

RIGHT — use `(cond) @ { }` with `$` as state dict for multiple values:

    [iter: 0, max: 3, text: $input, done: false]
      -> (!$.done && $.iter < $.max) @ {
        $.iter + 1 => $i
        process($.text) => $result
        $result.finished ? [iter: $i, max: $.max, text: $.text, done: true]
                         ! [iter: $i, max: $.max, text: $result.text, done: false]
      }

Pattern summary:

    Single value accumulation     -> fold(init) { $@ + $ }
    Per-item results + running    -> each(init) { ... $@ ... }
    Multiple state values / while -> (cond) @ { } with $ as state dict
    "while" and "for" keywords    -> DO NOT EXIST

### 6. No Exceptions

Errors halt execution. No try/catch. Use conditionals for error handling.
Built-in: `assert` (validate condition), `error` (halt with message).

### 7. Value Semantics (No References)

All copies are deep. All comparisons are by value. No object identity.

    [1, 2, 3] == [1, 2, 3]   # true (content equality)
    [1, 2] => $a
    $a => $b                  # $b is an independent deep copy

## Syntax Quick Reference

    Variables:     $name (always prefixed with $)
    Strings:       "hello {$var}"          # interpolation with {}
                   """..."""               # multiline (also interpolates)
    Numbers:       42, 3.14, -7
    Booleans:      true, false
    Lists:         [1, 2, 3]
                   [...$list, 4]               # spread: inline list elements
    Dicts:         [name: "alice", age: 30]    # identifier keys
                   [1: "one", 2: "two"]        # number keys (incl. negative: [-1: "neg"])
                   [true: "yes", false: "no"]  # boolean keys
                   [["a", "b"]: 1]             # multi-key: [a: 1, b: 1]
                   [$keyVar: value]            # variable key (must eval to string)
                   [($expr): value]            # computed key (must eval to string)
    Tuples:        *[1, 2, 3]              # for argument unpacking
    Closures:      |x|($x + 1)             # like lambda/arrow functions
    Type annot:    "hi" => $x:string       # lock type on capture
    Comments:      # single line only

## Pipes and $ Binding

`$` is the current piped value. Its meaning depends on context:

| Context | `$` contains |
|---|---|
| `-> { body }` | piped value |
| `-> each { }` | current item |
| `(cond) @ { }` | accumulated value |
| `@ { } ? cond` | accumulated value |
| `cond ? { } ! { }` | tested value |
| `-> ? { } ! { }` | piped value |
| `\|\|{ $.field }` in dict | the containing dict |
| `\|x\|{ }` stored closure | N/A — use parameters |

Implied `$`: bare `.method()` means `$ -> .method()`.
Example: `"hello" -> .upper` is the same as `"hello" -> $.upper()`.

## Control Flow

Conditional (if-else):

    cond ? then_expr ! else_expr
    cond ? then_expr                    # else returns ""

Piped conditional (`$` becomes condition):

    value -> ? then_expr ! else_expr

Multi-line conditionals (`?` and `!` work as line continuations):

    condition
      ? "yes"
      ! "no"
    value -> is_valid
      ? "ok"
      ! "error"
    $val -> .eq("A") ? "a"
      ! .eq("B") ? "b"
      ! "c"

Condition loop (NO `while` keyword — use `@` operator):

    init_value -> ($ < 10) @ { $ + 1 }  # $ is accumulator

Do-condition loop (body runs at least once):

    init_value -> @ { $ + 1 } ? ($ < 10)

Break (exits loop, returns collected results before break):

    [1,2,3,4,5] -> each { ($ == 3) ? break; $ }  # returns [1, 2]

Return (exits block or script with value):

    { 5 => $x; ($x > 3) ? ("big" -> return); "small" }  # returns "big"
    "done" -> return                                     # exits script with "done"

Assert (validate condition, halt if false, pass through if true):

    5 -> assert ($ > 0)                   # returns 5
    -1 -> assert ($ > 0)                  # ERROR: Assertion failed
    "" -> assert !.empty "Input required" # ERROR: Input required
    $val -> assert $:?list "Expected list" # type validation

Error (halt execution immediately with message):

    error "Something went wrong"           # halt with message
    "Operation failed" -> error            # piped form (must be string)
    error "Status: {$code}"               # interpolation works

Pass (returns `$` unchanged, explicit no-op):

    cond ? pass ! "fallback"               # preserve $ when condition true
    cond ? "value" ! pass                  # preserve $ when condition false
    "data" -> { [status: pass] }           # include $ in dict: [status: "data"]
    [1, -2, 3] -> map { ($ > 0) ? pass ! 0 }  # [1, 0, 3]

Note: `pass` requires pipe context. Using `pass` without `$` throws error.

## Collection Operators

| Operator | Execution | Returns | Break? |
|---|---|---|---|
| `-> each { }` | sequential | all body results | yes |
| `-> each(i) { $@ + $ }` | sequential | all with accumulator | yes |
| `-> map { }` | parallel | all body results | NO |
| `-> filter { }` | parallel | matching elements | NO |
| `-> fold(i) { $@ + $ }` | sequential | final result only | yes |

`$@` is the accumulator in `each(init)` and `fold(init)`.

Method shorthand in collection operators:

    ["a", "b"] -> map .upper            # ["A", "B"]
    ["", "x"] -> filter (!.empty)       # ["x"]
    ["a", "b"] -> map .pad_start(3, "0") # ["00a", "00b"] (with args)
    ["  HI  "] -> map .trim.lower       # ["hi"] (chained methods)

Body forms (all operators accept these):

    -> each { $ * 2 }                   # block ($ is current element)
    -> each ($ + 10)                    # grouped expression
    -> each |x| ($x * 2)               # inline closure
    -> each $double                     # variable closure
    -> each .upper                      # method shorthand
    -> each log                         # host function

Dict iteration (`$` contains `key` and `value` fields):

    [a: 1, b: 2] -> each { "{$.key}={$.value}" }   # ["a=1", "b=2"]
    [a: 1, b: 5] -> filter { $.value > 2 }          # entries where value > 2

String iteration (iterates over characters):

    "abc" -> each { "{$}!" }            # ["a!", "b!", "c!"]
    "hello" -> filter { $ != "l" }      # ["h", "e", "o"]

## Closures

Two ways to create closures:

**Block-closures:** `{ body }` in expression position

    { $ + 1 } => $inc                  # implicit $ parameter
    $inc(5)                            # 6
    5 -> $inc                          # 6 (pipe invocation)
    [x: { $ * 2 }]                     # dict value is closure
    type({ "hi" })                     # "closure"

**Explicit closures:** `|params| body`

    |x|($x + 1) => $inc                # named parameter
    |a, b|($a + $b) => $add            # multiple params
    |x = 0|($x + 1) => $inc_or_one     # default value
    |x: number|($x + 1) => $typed      # type annotation

`{ body }` vs `( expr )` distinction:

| Syntax | Semantics | Example |
|---|---|---|
| `{ body }` | Deferred (closure) | `{ $ + 1 } => $fn` |
| `( expr )` | Eager (immediate eval) | `( 5 + 1 ) => $x` gives 6 |

LATE BINDING: closures capture scope, not values. Variables resolve at call time.

`$` vs named params:
- Use `$` in inline pipes and loops: `"hello" -> { .upper }`
- Use named params in stored closures: `|x| ($x * 2) => $double`
- `$` is undefined when a stored closure is called later — always use params.

Zero-param dict closures (methods):

    [count: 3, double: ||{ $.count * 2 }] => $obj
    $obj.double                         # 6 ($ is bound to dict)

## Property Access

    $data.field                           # dict field
    $data[0], $data[-1]                   # list index (negative from end)
    $data.$key                            # variable as key
    $data.($i + 1)                        # computed key
    $data.(a || b)                        # try keys left-to-right
    $data.field ?? "default"              # default if missing
    $data.?field                          # existence check (boolean)
    $data.?$keyVar                        # variable existence check
    $data.?($expr)                        # computed existence check
    $data.?field&string                   # existence AND type check
    $data.?$key&number                    # variable existence + type check
    $data.?($a -> "{$}_b")&list           # computed existence + type check

## Dispatch Operators

**Dict dispatch** (single key) — pipe a value to a dict to match keys:

    $val -> [apple: "fruit", carrot: "veg"]        # "fruit" if $val is "apple"
    $val -> [apple: "fruit"] ?? "not found"         # default if no match
    $method -> [["GET", "HEAD"]: "safe", ["POST", "PUT"]: "unsafe"]  # multi-key

Type-aware matching (keys matched by value AND type):

    1 -> [1: "number", "1": "string"]              # "number"
    "1" -> [1: "number", "1": "string"]            # "string"
    true -> [true: "bool", "true": "str"]          # "bool"

**List dispatch** (index) — pipe a number to a list:

    0 -> ["first", "second"]                        # "first"
    -1 -> ["first", "second"]                       # "second" (last)
    5 -> ["a", "b"] ?? "not found"                  # default if out of bounds

**Hierarchical dispatch** (path navigation) — pipe a list of keys/indexes:

    ["name", "first"] -> [name: [first: "Alice"]]   # "Alice"
    [0, 1] -> [[1, 2, 3], [4, 5, 6]]                # 2
    ["users", 0, "name"] -> [users: [[name: "Alice"]]] # "Alice"
    [] -> [a: 1]                                    # [a: 1] (empty path = unchanged)
    ["a", "missing"] -> [a: [x: 1]] ?? "default"    # "default"

## Type Operations

`:type` — assert type (error if wrong): `42:number` passes; `"x":number` errors.
`:?type` — check type (boolean): `42:?number` is true; `"x":?number` is false.

Types: `string`, `number`, `boolean`, `list`, `dict`, `tuple`, `closure`.

Comparison methods:

    .eq(val) ==   .ne(val) !=   .lt(val) <   .gt(val) >   .le(val) <=   .ge(val) >=
    Example: $age -> .ge(18) ? "adult" ! "minor"

## Operator Precedence (Highest to Lowest)

1. Member access: `.field`, `[index]`
2. Type operators: `:type`, `:?type`
3. Unary: `-`, `!`
4. Multiplicative: `*`, `/`, `%`
5. Additive: `+`, `-`
6. Comparison: `==`, `!=`, `<`, `>`, `<=`, `>=`
7. Logical AND: `&&`
8. Logical OR: `||`
9. Default: `??`
10. Pipe: `->`
11. Capture: `=>`

Use parentheses to override: `(2 + 3) * 4`

## Extraction Operators

Destructure (`*<>`):

    [1, 2, 3] -> *<$a, $b, $c>          # $a=1, $b=2, $c=3
    [x: 1, y: 2] -> *<x: $a, y: $b>     # $a=1, $b=2
    [1, 2, 3] -> *<$first, _, $third>   # _ skips element

Slice (`/<start:stop:step>`):

    [0,1,2,3,4] -> /<1:3>               # [1, 2]
    [0,1,2,3,4] -> /<-2:>               # [3, 4]
    [0,1,2,3,4] -> /<::-1>              # [4,3,2,1,0] (reverse)
    "hello" -> /<1:4>                   # "ell"

## List Spread in Literals

Inline list elements into a new list using `...` (spread operator):

    [1, 2] => $a
    [...$a, 3]                          # [1, 2, 3]
    [...$a, ...$b]                      # concatenate lists
    [...($nums -> map {$ * 2})]         # spread expression result

## Tuples for Argument Unpacking

    *[1, 2, 3] -> $fn()                   # positional: $fn(1, 2, 3)
    *[b: 2, a: 1] -> $fn()                # named: $fn(a=1, b=2)
    *[...$list, 3] -> $fn()               # spread in tuple: combines elements

## Closure Chain (@)

Chains closures sequentially (each receives previous result):

    5 -> @[$inc, $double, $add10]       # (5+1)*2+10 = 22

## String Methods

| Method | Description |
|---|---|
| `.len` | length |
| `.empty` | is empty string |
| `.trim` | remove whitespace |
| `.upper` | uppercase |
| `.lower` | lowercase |
| `.str` | convert to string |
| `.num` | parse to number |
| `.head` | first character |
| `.tail` | last character |
| `.at(i)` | character at index |
| `.split(sep)` | split into list (default: newline) |
| `.lines` | split on newlines |
| `.join(sep)` | join list with separator |
| `.contains(s)` | substring check |
| `.starts_with(s)` | prefix check |
| `.ends_with(s)` | suffix check |
| `.index_of(s)` | first match position (-1 if none) |
| `.replace(p, r)` | replace first regex match |
| `.replace_all(p, r)` | replace all regex matches |
| `.match(regex)` | first match info (dict with matched, index, groups) |
| `.is_match(regex)` | boolean regex check |
| `.repeat(n)` | repeat n times |
| `.pad_start(n, f)` | pad start |
| `.pad_end(n, f)` | pad end |

## List/Dict Methods

| Method | Description |
|---|---|
| `.len` | length |
| `.empty` | is empty |
| `.head` | first element |
| `.tail` | last element |
| `.at(i)` | element at index |
| `.keys` | dict keys as list |
| `.values` | dict values as list |
| `.entries` | dict as list of [k, v] tuples |
| `.has(val)` | list contains value (deep equality) |
| `.has_any(list)` | list contains any value from candidates |
| `.has_all(list)` | list contains all values from candidates |

## Global Functions

| Function | Description |
|---|---|
| `type(val)` | returns type name |
| `log(val)` | print and pass through |
| `json(val)` | convert to JSON string |
| `identity(val)` | returns input unchanged |
| `range(start, end, step?)` | number sequence (iterator) |
| `repeat(val, count)` | repeat value n times (iterator) |
| `enumerate(coll)` | lists: [index, value]; dicts: [index, key, value] |

## Iterators

Lazy sequence generation. Collection operators auto-expand iterators.

    range(0, 5) -> each { $ * 2 }        # [0, 2, 4, 6, 8]
    repeat("x", 3) -> each { $ }         # ["x", "x", "x"]

`.first()` method (returns iterator for any collection):

    [1, 2, 3] -> .first()                # iterator at 1
    "abc" -> .first()                     # iterator at "a"

Iterator protocol (dict with `value`, `done`, `next`):

    $it.done                              # bool: is exhausted?
    $it.value                             # current element
    $it.next()                            # returns new iterator at next position

## Iteration Limits

Default: 10,000 iterations max for loops.
Override: `^(limit: N)` statement.

    ^(limit: 100) 0 -> ($ < 50) @ { $ + 1 }
    ^(limit: 3) $items -> map { slow_process($) }  # concurrency limit

## Script Return Values

| Return value | Exit code |
|---|---|
| `true` / non-empty string | 0 |
| `false` / empty string | 1 |
| `[0, "message"]` | 0 with message |
| `[1, "message"]` | 1 with message |
