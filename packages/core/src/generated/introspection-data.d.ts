export declare const LANGUAGE_REFERENCE = "RILL LANGUAGE REFERENCE\n=======================\n\nRill is designed to be generated by LLMs and understood by humans. The focus is\non auditable LLM output, not ergonomic human authoring.\n\nESSENTIALS\n----------\n1. Variables use $ prefix ALWAYS:  5 => $x  (no assignment operator =)\n2. Pipe with ->, capture with =>:  \"hello\" => $x -> .upper => $y\n3. No null/undefined, no try/catch, no truthiness (conditions must be boolean)\n4. Variables lock to first type:   \"hi\" => $x; 42 => $x  # ERROR\n5. Loops cannot modify outer vars: use fold, each(init), or $ as state dict\n\nSTRENGTHS AND USE CASES\n-----------------------\nStrengths:\n  - Unambiguous syntax: $ prefix, explicit operators, no implicit coercion\n  - Single-pass parseable: LLMs generate correct code without symbol tables\n  - Readable by humans: pipe chains show data flow left-to-right\n  - Safe defaults: immutable values, type locking, no null/undefined\n\nUse cases:\n  - Workflow orchestration: chain LLM calls, API requests, transformations\n  - State machines: (cond) @ { } loops with $ as state dict\n  - Data pipelines: each/map/filter/fold process collections declaratively\n  - Prompt engineering: parse LLM output with parse_json, parse_xml, parse_fence\n\nState machine pattern ($ carries state through iterations):\n  [state: \"init\", data: $input]\n    -> ($.state != \"done\") @ {\n      $.state -> [\n        init: { [state: \"process\", data: transform($.data)] },\n        process: { [state: \"done\", data: finalize($.data)] }\n      ]\n    }\n\nNAMING CONVENTION: snake_case\n-----------------------------\nUse snake_case for all identifiers:\n  $user_name, $item_list, $is_valid    # variables\n  $double_value, $cleanup_text         # closures\n  [first_name: \"x\", last_name: \"y\"]    # dict keys\n\nWHY VARIABLES USE $ PREFIX\n--------------------------\nThe $ prefix enables single-pass parsing without a symbol table:\n\n  name()    -> host function call\n  $name()   -> closure invocation\n  $name     -> variable reference\n  name      -> dict key literal\n\nWithout $, \"process(data)\" is ambiguous: is process a host function or stored\nclosure? Is data a variable or key? This would require tracking all declarations.\n\nSPACING RULES\n-------------\nOperators:    space both sides       5 + 3, $x -> .upper, \"a\" => $b\nParentheses:  no inner space         ($x + 1), ($ > 3) ? \"yes\"\nBraces:       space inside           { $x + 1 }, each { $ * 2 }\nBrackets:     no inner space         $list[0], $dict.items[1]\nLiterals:     space after , and :    [1, 2, 3], [name: \"x\", age: 30]\nClosures:     space after params     |x| ($x * 2), |a, b| { $a + $b }\nMethods:      no space before . or ( $str.upper(), $list.join(\", \")\nPipes:        space both sides       \"x\" -> .upper -> .len\nContinuations: indent 2 spaces       $data\n                                       -> .filter { $.active }\n                                       -> map { $.name }\n\nIMPLICIT $ SHORTHAND (always prefer)\n------------------------------------\n$.method()  ->  .method            \"x\" -> .upper  (not $.upper())\nfunc($)     ->  func               \"x\" -> log     (not log($))\n$fn($)      ->  $fn                5 -> $double   (not $double($))\n\nDon't capture just to continue - use line continuation instead:\n  # avoid                          # good\n  \"x\" => $a                        \"x\"\n  $a -> .upper => $b                 -> .upper\n  $b -> .len                         -> .len\n\nOnly capture when the variable is reused later in the code.\n\nCRITICAL DIFFERENCES FROM MAINSTREAM LANGUAGES\n----------------------------------------------\n\n1. NO ASSIGNMENT OPERATOR\n   Wrong: x = 5           Mainstream: x = value\n   Right: 5 => $x         Rill: value => $x\n\n   Pipe (->): passes value to next operation\n   Capture (=>): stores value AND continues chain\n   Example: \"hello\" => $x -> .upper => $y   # $x=\"hello\", $y=\"HELLO\"\n\n2. NO NULL/UNDEFINED\n   Empty values (\"\", [], [:]) exist. \"No value\" cannot be represented.\n   Use ?? for defaults: $dict.field ?? \"default\"\n   Use .empty to check: $str -> .empty ? \"was empty\"\n   Mainstream: null/undefined      Rill: ?? default, .? existence check\n\n3. NO TRUTHINESS\n   Conditions MUST be boolean. No implicit coercion.\n   Wrong: \"\" ? \"yes\" ! \"no\"       Right: \"\" -> .empty ? \"yes\" ! \"no\"\n   Wrong: 0 ? \"yes\" ! \"no\"        Right: (0 == 0) ? \"yes\" ! \"no\"\n   Negation (!) also requires boolean:\n   Right: !true                          # false\n   Right: \"hello\" -> .empty -> (!$)      # true (negates boolean from .empty)\n   Wrong: !\"hello\"                       # ERROR: Negation requires boolean\n   Mainstream: if \"\" / if 0              Rill: .empty, == 0, :?type\n\n4. VARIABLES LOCK TO FIRST TYPE\n   \"hello\" => $x\n   42 => $x        # ERROR: cannot assign number to string variable\n\n5. NO VARIABLE SHADOWING (CRITICAL FOR LOOPS)\n   Child scopes can READ parent variables but cannot WRITE or redeclare them.\n   Variables created inside blocks/loops do NOT leak out.\n\n   WRONG - outer variable modification (NEVER works):\n     0 => $count\n     [1, 2, 3] -> each { $count + 1 => $count }  # creates LOCAL $count\n     $count                                       # still 0!\n\n   WRONG - \"while\" keyword does not exist:\n     while ($i < 10) { $i + 1 => $i }            # SYNTAX ERROR\n\n   RIGHT - use fold for reduction:\n     [1, 2, 3] -> fold(0) { $@ + $ }             # 6 ($@ is accumulator)\n\n   RIGHT - use each(init) for results AND accumulator:\n     [1, 2, 3] -> each(0) { $@ + $ }             # [1, 3, 6] (running totals)\n\n   RIGHT - use (cond) @ { } with $ as state dict for multiple values:\n     [iter: 0, max: 3, text: $input, done: false]\n       -> (!$.done && $.iter < $.max) @ {\n         $.iter + 1 => $i\n         process($.text) => $result\n         $result.finished ? [iter: $i, max: $.max, text: $.text, done: true]\n                          ! [iter: $i, max: $.max, text: $result.text, done: false]\n       }\n\n   Pattern summary:\n     Single value accumulation     -> fold(init) { $@ + $ }\n     Per-item results + running    -> each(init) { ... $@ ... }\n     Multiple state values / while -> (cond) @ { } with $ as state dict\n     \"while\" and \"for\" keywords    -> DO NOT EXIST\n   Mainstream: count += 1 in loop    Rill: fold(0) { $@ + 1 } or $ accumulator\n\n6. NO EXCEPTIONS\n   Errors halt execution. No try/catch. Use conditionals for error handling.\n   Built-in: assert (validate condition), error (halt with message).\n   Mainstream: try { } catch { }     Rill: assert, conditionals, error\n\n7. VALUE SEMANTICS (no references)\n   All copies are deep. All comparisons are by value. No object identity.\n   [1, 2, 3] == [1, 2, 3]   # true (content equality)\n   [1, 2] => $a\n   $a => $b                  # $b is an independent deep copy\n   Mainstream: a === b (reference)   Rill: == always compares by value\n   Mainstream: a = b (shared ref)    Rill: => always deep-copies\n\nSYNTAX QUICK REFERENCE\n----------------------\n\nVariables:     $name (always prefixed with $)\nStrings:       \"hello {$var}\"          # interpolation with {}\n               \"\"\"...\"\"\"               # multiline (also interpolates)\nNumbers:       42, 3.14, -7\nBooleans:      true, false\nLists:         [1, 2, 3]\n               [...$list, 4]               # spread: inline list elements\nDicts:         [name: \"alice\", age: 30]    # identifier keys\n               [1: \"one\", 2: \"two\"]        # number keys (incl. negative: [-1: \"neg\"])\n               [true: \"yes\", false: \"no\"]  # boolean keys\n               [[\"a\", \"b\"]: 1]             # multi-key: [a: 1, b: 1]\n               [$keyVar: value]            # variable key (must eval to string)\n               [($expr): value]            # computed key (must eval to string)\nTuples:        *[1, 2, 3]              # for argument unpacking\nClosures:      |x|($x + 1)             # like lambda/arrow functions\nType annot:    \"hi\" => $x:string       # lock type on capture\nComments:      # single line only\n\nPIPES AND $ BINDING\n-------------------\n\n$ is the current piped value. Its meaning depends on context:\n\n| Context                    | $ contains              |\n|----------------------------|-------------------------|\n| -> { body }                | piped value             |\n| -> each { }                | current item            |\n| (cond) @ { }               | accumulated value       |\n| @ { } ? cond               | accumulated value       |\n| cond ? { } ! { }           | tested value            |\n| -> ? { } ! { }             | piped value             |\n| ||{ $.field } in dict      | the containing dict     |\n| |x|{ } stored closure      | N/A - use parameters    |\n\nImplied $: bare .method() means $ -> .method()\nExample: \"hello\" -> .upper   # same as \"hello\" -> $.upper()\n\nCONTROL FLOW\n------------\n\nConditional (if-else):\n  cond ? then_expr ! else_expr\n  cond ? then_expr                    # else returns \"\"\n\nPiped conditional ($ becomes condition):\n  value -> ? then_expr ! else_expr\n\nCondition loop (NO \"while\" keyword - use @ operator):\n  init_value -> ($ < 10) @ { $ + 1 }  # $ is accumulator\n\nDo-condition loop (body runs at least once):\n  init_value -> @ { $ + 1 } ? ($ < 10)\n\nBreak (exits loop, returns collected results before break):\n  [1,2,3,4,5] -> each { ($ == 3) ? break; $ }  # returns [1, 2]\n\nReturn (exits block or script with value):\n  { 5 => $x; ($x > 3) ? (\"big\" -> return); \"small\" }  # returns \"big\"\n  \"done\" -> return                                     # exits script with \"done\"\n\nAssert (validate condition, halt if false, pass through if true):\n  5 -> assert ($ > 0)                   # returns 5\n  -1 -> assert ($ > 0)                  # ERROR: Assertion failed\n  \"\" -> assert !.empty \"Input required\" # ERROR: Input required\n  $val -> assert $:?list \"Expected list\" # type validation\n\nError (halt execution immediately with message):\n  error \"Something went wrong\"           # halt with message\n  \"Operation failed\" -> error            # piped form (must be string)\n  error \"Status: {$code}\"               # interpolation works\n\nPass (returns $ unchanged, explicit no-op):\n  cond ? pass ! \"fallback\"               # preserve $ when condition true\n  cond ? \"value\" ! pass                  # preserve $ when condition false\n  \"data\" -> { [status: pass] }           # include $ in dict: [status: \"data\"]\n  [1, -2, 3] -> map { ($ > 0) ? pass ! 0 }  # [1, 0, 3]\n  Note: pass requires pipe context. Using pass without $ throws error.\n\nCOLLECTION OPERATORS\n--------------------\n\n| Operator           | Execution  | Returns              | Break? |\n|--------------------|------------|----------------------|--------|\n| -> each { }        | sequential | all body results     | yes    |\n| -> each(i) { $@+$} | sequential | all with accumulator | yes    |\n| -> map { }         | parallel   | all body results     | NO     |\n| -> filter { }      | parallel   | matching elements    | NO     |\n| -> fold(i) { $@+$} | sequential | final result only    | yes    |\n\n$@ is the accumulator in each(init) and fold(init).\n\nMethod shorthand in collection operators:\n  [\"a\", \"b\"] -> map .upper            # [\"A\", \"B\"]\n  [\"\", \"x\"] -> filter (!.empty)       # [\"x\"]\n  [\"a\", \"b\"] -> map .pad_start(3, \"0\") # [\"00a\", \"00b\"] (with args)\n  [\"  HI  \"] -> map .trim.lower       # [\"hi\"] (chained methods)\n\nBody forms (all operators accept these):\n  -> each { $ * 2 }                   # block ($ is current element)\n  -> each ($ + 10)                    # grouped expression\n  -> each |x| ($x * 2)               # inline closure\n  -> each $double                     # variable closure\n  -> each .upper                      # method shorthand\n  -> each log                         # host function\n\nDict iteration ($ contains key and value fields):\n  [a: 1, b: 2] -> each { \"{$.key}={$.value}\" }   # [\"a=1\", \"b=2\"]\n  [a: 1, b: 5] -> filter { $.value > 2 }          # entries where value > 2\n\nString iteration (iterates over characters):\n  \"abc\" -> each { \"{$}!\" }            # [\"a!\", \"b!\", \"c!\"]\n  \"hello\" -> filter { $ != \"l\" }      # [\"h\", \"e\", \"o\"]\n\nCLOSURES\n--------\n\nBLOCK-CLOSURES vs EXPLICIT CLOSURES:\n\nTwo ways to create closures:\n\n1. Block-closures: { body } in expression position\n   { $ + 1 } => $inc                  # implicit $ parameter\n   $inc(5)                            # 6\n   5 -> $inc                          # 6 (pipe invocation)\n   [x: { $ * 2 }]                     # dict value is closure\n   type({ \"hi\" })                     # \"closure\"\n\n2. Explicit closures: |params| body\n   |x|($x + 1) => $inc                # named parameter\n   |a, b|($a + $b) => $add            # multiple params\n   |x = 0|($x + 1) => $inc_or_one     # default value\n   |x: number|($x + 1) => $typed      # type annotation\n\nCRITICAL: { } vs ( ) distinction\n\n| Syntax       | Semantics              | Example                    |\n|--------------|------------------------|----------------------------|\n| { body }     | Deferred (closure)     | { $ + 1 } => $fn  # closure |\n| ( expr )     | Eager (immediate eval) | ( 5 + 1 ) => $x  # 6        |\n\nWhen to use:\n  { body } => $fn     # store closure for later use\n  ( expr ) => $x      # store result value immediately\n\nPIPE TARGET: { } creates closure then immediately invokes it:\n  5 -> { $ + 1 }      # 6 (create closure, invoke with 5)\n  5 -> ($ + 1)        # 6 (evaluate expression with $=5)\n  Same observable result, different mechanism. Error messages differ.\n\nBlock-closure invocation:\n  { $ + 1 } => $inc\n  $inc(5)                             # direct call: 6\n  5 -> $inc                           # pipe call: 6\n  [1,2,3] -> map $inc                 # in collection op\n\nLATE BINDING: closures capture scope, not values. Variables resolve at call time.\n\n$ vs named params:\n  Use $ in inline pipes and loops:     \"hello\" -> { .upper }\n  Use named params in stored closures: |x| ($x * 2) => $double\n  $ is undefined when a stored closure is called later \u2014 always use params.\n\nZero-param dict closures (methods):\n  [count: 3, double: ||{ $.count * 2 }] => $obj\n  $obj.double                         # 6 ($ is bound to dict)\n\nPROPERTY ACCESS\n---------------\n\n$data.field                           # dict field\n$data[0], $data[-1]                   # list index (negative from end)\n$data.$key                            # variable as key\n$data.($i + 1)                        # computed key\n$data.(a || b)                        # try keys left-to-right\n$data.field ?? \"default\"              # default if missing\n$data.?field                          # existence check (boolean)\n$data.?$keyVar                        # variable existence check\n$data.?($expr)                        # computed existence check\n$data.?field&string                   # existence AND type check\n$data.?$key&number                    # variable existence + type check\n$data.?($a -> \"{$}_b\")&list           # computed existence + type check\n\nDISPATCH OPERATORS\n------------------\n\nDICT DISPATCH (single key):\nPipe a value to a dict to match keys and return associated values:\n  $val -> [apple: \"fruit\", carrot: \"veg\"]        # returns \"fruit\" if $val is \"apple\"\n  $val -> [apple: \"fruit\"] ?? \"not found\"         # default if no match\n  $method -> [[\"GET\", \"HEAD\"]: \"safe\", [\"POST\", \"PUT\"]: \"unsafe\"]  # multi-key dispatch\n\nType-aware matching (keys matched by value AND type):\n  1 -> [1: \"number\", \"1\": \"string\"]              # \"number\" (number key matches)\n  \"1\" -> [1: \"number\", \"1\": \"string\"]            # \"string\" (string key matches)\n  true -> [true: \"bool\", \"true\": \"str\"]          # \"bool\" (boolean key matches)\n\nLIST DISPATCH (index):\nPipe a number to a list to get element at index:\n  0 -> [\"first\", \"second\"]                        # \"first\"\n  -1 -> [\"first\", \"second\"]                       # \"second\" (last)\n  5 -> [\"a\", \"b\"] ?? \"not found\"                  # default if out of bounds\n\nHIERARCHICAL DISPATCH (path navigation):\nPipe a list of keys/indexes to navigate nested structures:\n  [\"name\", \"first\"] -> [name: [first: \"Alice\"]]   # \"Alice\" (dict path)\n  [0, 1] -> [[1, 2, 3], [4, 5, 6]]                 # 2 (list path)\n  [\"users\", 0, \"name\"] -> [users: [[name: \"Alice\"]]] # \"Alice\" (mixed)\n  [] -> [a: 1]                                    # [a: 1] (empty path = unchanged)\n  [\"a\", \"missing\"] -> [a: [x: 1]] ?? \"default\"    # \"default\" (missing key)\n\nTYPE OPERATIONS\n---------------\n\n:type   - assert type (error if wrong): 42:number passes; \"x\":number errors\n:?type  - check type (boolean): 42:?number is true; \"x\":?number is false\n\nTypes: string, number, boolean, list, dict, tuple, closure\n\nComparison methods (for readable conditionals):\n  .eq(val) ==   .ne(val) !=   .lt(val) <   .gt(val) >   .le(val) <=   .ge(val) >=\n  Example: $age -> .ge(18) ? \"adult\" ! \"minor\"\n\nOPERATOR PRECEDENCE (highest to lowest)\n---------------------------------------\n\n1.  Member access:   .field, [index]\n2.  Type operators:  :type, :?type\n3.  Unary:           -, !\n4.  Multiplicative:  *, /, %\n5.  Additive:        +, -\n6.  Comparison:      ==, !=, <, >, <=, >=\n7.  Logical AND:     &&\n8.  Logical OR:      ||\n9.  Default:         ??\n10. Pipe:            ->\n11. Capture:         =>\n\nUse parentheses to override: (2 + 3) * 4\n\nEXTRACTION OPERATORS\n--------------------\n\nDestructure (*<>):\n  [1, 2, 3] -> *<$a, $b, $c>          # $a=1, $b=2, $c=3\n  [x: 1, y: 2] -> *<x: $a, y: $b>     # $a=1, $b=2\n  [1, 2, 3] -> *<$first, _, $third>   # _ skips element\n\nSlice (/<start:stop:step>):\n  [0,1,2,3,4] -> /<1:3>               # [1, 2]\n  [0,1,2,3,4] -> /<-2:>               # [3, 4]\n  [0,1,2,3,4] -> /<::-1>              # [4,3,2,1,0] (reverse)\n  \"hello\" -> /<1:4>                   # \"ell\"\n\nLIST SPREAD IN LITERALS\n-----------------------\n\nInline list elements into a new list using ... (spread operator):\n  [1, 2] => $a\n  [...$a, 3]                          # [1, 2, 3]\n  [...$a, ...$b]                      # concatenate lists\n  [...($nums -> map {$ * 2})]         # spread expression result\n\nMULTI-KEY DICT LITERALS\n-----------------------\n\nMap multiple keys to the same value using list syntax:\n  [[\"a\", \"b\"]: 1]                     # [a: 1, b: 1]\n  [[1, \"1\"]: \"x\"]                     # [1: \"x\", \"1\": \"x\"] (mixed types)\n  [a: 0, [\"b\", \"c\"]: 1]               # [a: 0, b: 1, c: 1] (mixed entries)\n\nTUPLES FOR ARGUMENT UNPACKING\n-----------------------------\n\n*[1, 2, 3] -> $fn()                   # positional: $fn(1, 2, 3)\n*[b: 2, a: 1] -> $fn()                # named: $fn(a=1, b=2)\n*[...$list, 3] -> $fn()               # spread in tuple: combines elements\n\nCLOSURE CHAIN (@)\n-----------------\n\nChains closures sequentially (each receives previous result):\n  5 -> @[$inc, $double, $add10]       # (5+1)*2+10 = 22\n\nSTRING METHODS\n--------------\n\n.len            length                    .empty          is empty string\n.trim           remove whitespace         .upper          uppercase\n.lower          lowercase                 .str            convert to string\n.num            parse to number           .head           first character\n.tail           last character            .at(i)          character at index\n.split(sep)     split into list (default: newline)\n.lines          split on newlines         .join(sep)      join list with separator\n.contains(s)    substring check           .starts_with(s) prefix check\n.ends_with(s)   suffix check              .index_of(s)    first match position (-1 if none)\n.replace(p,r)   replace first regex match\n.replace_all(p,r) replace all regex matches\n.match(regex)   first match info (dict with matched, index, groups)\n.is_match(regex) boolean regex check\n.repeat(n)      repeat n times: \"ab\" -> .repeat(3)  # \"ababab\"\n.pad_start(n,f) pad start: \"42\" -> .pad_start(5, \"0\")  # \"00042\"\n.pad_end(n,f)   pad end: \"42\" -> .pad_end(5, \"0\")  # \"42000\"\n\nLIST/DICT METHODS\n-----------------\n\n.len            length                    .empty          is empty\n.head           first element             .tail           last element\n.at(i)          element at index          .keys           dict keys as list\n.values         dict values as list       .entries        dict as list of [k, v] tuples\n.has(val)       list contains value (deep equality)\n.has_any(list)  list contains any value from candidates\n.has_all(list)  list contains all values from candidates\n\nPARSING FUNCTIONS (for LLM output)\n----------------------------------\n\nparse_auto(str)           auto-detect format\nparse_json(str)           parse JSON (repairs common errors)\nparse_xml(str, tag?)      extract XML tag content\nparse_fence(str, lang?)   extract fenced code block\nparse_fences(str)         all fenced blocks as list\nparse_frontmatter(str)    parse --- delimited YAML + body\nparse_checklist(str)      parse markdown task lists\n\nGLOBAL FUNCTIONS\n----------------\n\ntype(val)                 returns type name (string, number, boolean, list, dict, closure, tuple)\nlog(val)                  print and pass through\njson(val)                 convert to JSON string\nidentity(val)             returns input unchanged\nrange(start, end, step?)  number sequence (iterator)\nrepeat(val, count)        repeat value n times (iterator)\nenumerate(coll)           lists: [index, value]; dicts: [index, key, value]\n\nITERATORS\n---------\n\nLazy sequence generation. Collection operators auto-expand iterators.\n\nBuilt-in iterators:\n  range(0, 5) -> each { $ * 2 }        # [0, 2, 4, 6, 8]\n  repeat(\"x\", 3) -> each { $ }         # [\"x\", \"x\", \"x\"]\n\n.first() method (returns iterator for any collection):\n  [1, 2, 3] -> .first()                # iterator at 1\n  \"abc\" -> .first()                     # iterator at \"a\"\n\nIterator protocol (dict with value, done, next):\n  $it.done                              # bool: is exhausted?\n  $it.value                             # current element\n  $it.next()                            # returns new iterator at next position\n\nITERATION LIMITS\n----------------\n\nDefault: 10,000 iterations max for loops.\nOverride: ^(limit: N) statement\n\n  ^(limit: 100) 0 -> ($ < 50) @ { $ + 1 }\n  ^(limit: 3) $items -> map { slow_process($) }  # concurrency limit\n\nSCRIPT RETURN VALUES\n--------------------\n\ntrue / non-empty string -> exit code 0\nfalse / empty string    -> exit code 1\n[0, \"message\"]          -> exit code 0 with message\n[1, \"message\"]          -> exit code 1 with message\n";
//# sourceMappingURL=introspection-data.d.ts.map